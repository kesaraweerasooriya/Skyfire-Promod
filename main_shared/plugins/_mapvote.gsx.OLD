#include plugins\_common;
init() {
	startMapvote();
}

startMapvote()
{	
	maps = "gametype sd map mp_backlot gametype sd map mp_citystreets gametype sd map mp_crash gametype sd map mp_crossfire gametype sd map mp_strike";
	level.windowheight = 150;
	level.windowwidth  = 500;
	level.borderwidth  = 20;
	level.maps4vote    = 5;
	maprotation = strTok(maps," ");
	level.voteablemaps = [];
	hud = [];
	tryes = 0;
	i = 0;
	while(level.voteablemaps.size < level.maps4vote && tryes < 100) {
		tryes++;
		i = randomint(maprotation.size);
		while(maprotation[i] != "gametype")
			i = randomint(maprotation.size);
		i+=2;
		if((i+1)<maprotation.size && maprotation[i] == "map" && isLegal(maprotation[i+1] + ";" + maprotation[i-1]))
			level.voteablemaps[level.voteablemaps.size] = maprotation[i+1] + ";" + maprotation[i-1];
	}

	level.mapvote = true;
	level notify("mapvote");

	arraymaps = level.voteablemaps;

	//center
	hud[0] = addTextHud( level, 0, 0, .6, "center", "middle", "center", "middle", 0, 100 );
	hud[0] setShader("white",level.windowwidth+level.borderwidth+level.borderwidth,level.windowheight);
	hud[0].color = (0,0,0);
	hud[0] thread fadeIn(.3);
	//text
	hud[1] = addTextHud( level, 0, level.windowheight/-2-8, 1, "center", "bottom", "center", "middle", 2.2, 102 );
	hud[1] setText("VOTE");
	hud[1].color = (0.402, 0.937 ,0.464);
	hud[1] thread fadeIn(.3);
	//timer
	hud[2] = addTextHud( level, level.windowwidth/2 - 20, level.windowheight/-2-8, 1, "center", "bottom", "center", "middle", 2.2, 102 );
	hud[2] SetTenthsTimer(15);
	hud[2] thread fadeIn(.3);
	
	//red top bg
	hud[3] = addTextHud( level, 0, level.windowheight/-2+5, .8, "center", "bottom", "center", "middle", 2.2, 101 );
	hud[3].color = (1, 0.41 ,0.29);
	hud[3] SetShader("white",level.windowwidth+level.borderwidth+level.borderwidth,50);
	hud[3] thread fadeIn(.3);
	
	//voting results
	map = [];
	for(i=0;i<arraymaps.size;i++) {
		index = i + hud.size;
		hud[index] = addTextHud( level, -55, level.windowheight/-2+11.5+(i*26.8), 1, "left", "top", "center", "middle", 1.4, 102 );
		hud[index] setText("-");
		map[arraymaps[i]] = hud[index];
		hud[index] thread fadeIn(.3);
	}

	players = getAllPlayers();
	for(i=0;i<players.size;i++)
	{
		if(isDefined(players[i]) && isFalse(players[i].pers["isBot"]))
			players[i] thread PlayerVote();
	}

	addConnectThread(::PlayerVote);

	wait .1;

	level thread updateVotes(arraymaps,map);
	
	for(y=15;y>0;y--) {
		if(!(y%2) || y<6)
			level thread playSoundOnAllPlayers( "ui_mp_timer_countdown" );
		wait 1;
	}
	level notify("end_vote");
	for(i=0;i<arraymaps.size;i++)
		map[arraymaps[i]] thread fadeOut(.5);

	hud[2] thread fadeOut(.5);
	level.mapvotes thread fadeOut(.5);

	players = getAllPlayers();
	for(i=0;i<players.size;i++)
		if(isDefined(players[i]) && isDefined(players[i].mapvote_selection))
			players[i].mapvote_selection thread fadeOut(.5);

	wait .5;


	hud[2] = addTextHud( level, 0, -20, 1, "center", "middle", "center", "middle", 2.2, 102 );
	hud[2] setText("Next Map:");
	hud[2].color = (0.402, 0.937 ,0.464);
	hud[2] thread fadeIn(.5);

	size = hud.size;
	hud[size] = addTextHud( level, 0, 10, 1, "center", "middle", "center", "middle", 3, 102 );
	hud[size] setText(getMapNameString(strTok(level.winning,";")[0]) + " " + getGameTypeString(strTok(level.winning,";")[1]));
	hud[size].color = (0.402, 0.937 ,0.464);
	hud[size] thread fadeIn(.5);
	
	wait 3;
	blackscreen = addTextHud( level, 0, 0, 1, "center", "middle", "center", "middle", 3, 9999998 );
	blackscreen setShader("white",1000,1000);
	blackscreen.color = (0,0,0);
	
	blackscreen1 = addTextHud( level, 0, 0, 1, "center", "middle", "center", "middle", 3, 9999998 );
	blackscreen1 setShader("white",1000,1000);
	blackscreen1.color = (0,0,0);
	
	blackscreen thread fadeIn(1.5);
	blackscreen1 thread fadeIn(1.5);
	wait 1.5;
	
	blacktext = addTextHud( level, 0, 0, 1, "center", "middle", "center", "middle", 2.5, 9999999 );
	blacktext setText("sF:Alpha Search & Destroy");
	
	blacktext thread fadeIn(1.5);
	wait 2;
	blacktext thread fadeOut(1.5);

	wait 1.8;
	changeMap();
}

updateVotes(arraymaps,map) {
	level endon("end_vote");
	string = "";
	array = [];
	mostvotes = 0;
	players = getAllPlayers();
	level.mapvotes = addTextHud( level, level.windowwidth/-2 + 3, level.windowheight/-2+8, 1, "left", "top", "center", "middle", 2.2, 102 );
	level.mapvotes thread fadeIn(.3);
	while(1) {
		array = [];
		mostvotes = 0;
		level.winning = getDvar("mapname") + ";" +getDvar("g_gametype");//just in case
		players = getAllPlayers();
		for(i=0;i<players.size;i++) {
			if(isDefined(players[i]) && isDefined(players[i].votedmap)) {
				if(!isDefined(array[players[i].votedmap]))
					array[players[i].votedmap] = [];
				array[players[i].votedmap][array[players[i].votedmap].size] = players[i];
			}
		}
		string = "";
		for(i=0;i<arraymaps.size;i++) { 
			if(!isDefined(array[arraymaps[i]]))
				voted = 0;
			else 
				voted = array[arraymaps[i]].size;
			string += (voted + " - " + getMapNameString(strTok(arraymaps[i],";")[0]) + " " + getGameTypeString(strTok(arraymaps[i],";")[1]) + "\n");
			level.voteablemapstring = "";
			if(isDefined(array[arraymaps[i]])) {
				for(k=0;k<array[arraymaps[i]].size;k++) {
					if(level.voteablemapstring.size < 30 )
						level.voteablemapstring += (array[arraymaps[i]][k].name + ", ");
					else {
						level.voteablemapstring = getSubStr(level.voteablemapstring,0,level.voteablemapstring.size-2);
						level.voteablemapstring += (" and " + (array[arraymaps[i]].size-k+1) + " , ...");
						k = 999;
					} 
				}
				if(mostvotes < array[arraymaps[i]].size) {
					mostvotes = array[arraymaps[i]].size;
					level.winning = arraymaps[i];
				}
				level.voteablemapstring = getSubStr(level.voteablemapstring,0,level.voteablemapstring.size-2);
				map[arraymaps[i]] setText(level.voteablemapstring);
			}
			else 
				map[arraymaps[i]] setText("");
		}
		level.mapvotes setText(string);
		wait 1;
		level.mapvotes destroy();
		level.mapvotes = addTextHud( level, level.windowwidth/-2 + 3, level.windowheight/-2+8, 1, "left", "top", "center", "middle", 2.2, 102 );
	}
}

changeMap() 
{ 	
	setDvar( "sv_maprotationcurrent", "gametype " + strTok(level.winning,";")[1] + " map " + strTok(level.winning,";")[0] );
	
	if(isDefined(game["PROMOD_MATCH_MODE"]) && game["PROMOD_MATCH_MODE"] == "match") {
		map_restart(false);
		return;
	}
	exitLevel(false);
}

PlayerVote() {
	self endon("disconnect");
	level endon("end_vote");
	
	self thread Rotate();

	wait .05;

	self.sessionteam = "spectator";
	self.sessionstate = "spectator";
	self [[level.spawnSpectator]]();

	ads = self AdsButtonPressed();
	self.howto = addTextHud( self, 0, level.windowheight/2+5, 1, "center", "top", "center", "middle", 2.4, 101 );
	self.howto thread fadeIn(.3);
	self.howto setText("Press Fire to Vote");
	while(!self AttackButtonPressed() && ads == self AdsButtonPressed()) wait .05;
	self.howto thread fadeOut(1);
	selected = -1;
	offset = 26.8;
	self.mapvote_selection = addTextHud( self, 0, level.windowheight/-2+9+(selected*offset), 1, "center", "top", "center", "middle", 1.6, 101 );
	self.mapvote_selection setShader("white",level.windowwidth+level.borderwidth+level.borderwidth,25);
	self.mapvote_selection.color = (0.402, 0.937 ,0.464);
	self.mapvote_selection.alpha = 0.5;
	self.mapvote_selection thread fadeIn(.3);
	maps = level.voteablemaps;
	while(1) {
		self allowSpectateTeam( "allies", false );
		self allowSpectateTeam( "axis", false );
		self allowSpectateTeam( "freelook", false );
		self allowSpectateTeam( "none", true );
		if(ads != self AdsButtonPressed()) {
			ads = self AdsButtonPressed();
			selected--;
			if(selected < 0)
				selected = maps.size-1;
			self.votedmap = maps[selected];
			self.mapvote_selection MoveOverTime(.1);
			self.mapvote_selection.y = level.windowheight/-2+9+(selected*offset);
		}
		if(self AttackButtonPressed()) {
			selected++;
			if(selected >= maps.size)
				selected = 0;
			self.votedmap = maps[selected];
			self.mapvote_selection MoveOverTime(.1);
			self.mapvote_selection.y = level.windowheight/-2+9+(selected*offset);
			for(k=0;k<8 && self attackButtonPressed();k++) wait .05;
		}
		wait .05;
	}
}

Rotate() {
	self endon("disconnect");
	wait .05;
	i=randomint(360);
	offset = 150;
	centerposition = self.origin;
	link = spawn("script_model",(centerposition[0]+(offset*cos(i)),centerposition[1]+(offset*sin(i)),centerposition[2]));
	self setOrigin((centerposition[0]+(offset*cos(i)),centerposition[1]+(offset*sin(i)),centerposition[2]));
	self linkTo(link);
	while(1) {
		for(;i<360;i+=1) {
			self FreezeControls(true);
			if(i%3==0)
				link moveTo((centerposition[0]+(offset*cos(i)),centerposition[1]+(offset*sin(i)),centerposition[2]),.25);
			self setPlayerAngles((0,i-180,0));
			wait .05;
		}
		i=0;
	}
}

destroyAfterTime(time) {
	wait time;
	if(isDefined(self)) 
		self delete();
}

getGameTypeString( gt ) {
	switch( toLower( gt ) ) {
		case "war":
			gt = "";	
		default:
			gt = "";
	}
	return gt;
}

isLegal(map) {
	if(map == (getDvar("mapname") + ";" + getDvar("g_gametype"))) 
		return false;
	for(i=0;i<level.voteablemaps.size;i++)
		if(level.voteablemaps[i] == map)
			return false;
	return true;
}